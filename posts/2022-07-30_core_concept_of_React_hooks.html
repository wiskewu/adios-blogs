<html lang="zh"><head><title>Adiós Blog - React Hooks核心逻辑实现</title><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="description" content="Adiós的个人博客网站"/><meta name="author"/><meta name="kewords" content="Adiós's independent blog"/><link rel="stylesheet" href="/adios-blogs/statics/css/purecss/purecss-min@2.1.0.css"/><link rel="stylesheet" href="/adios-blogs/statics/css/purecss/purecss@2.1.0-base-min.css"/><link rel="stylesheet" href="/adios-blogs/statics/css/purecss/purecss@2.1.0-grids-responsive-min.css"/><link rel="stylesheet" href="/adios-blogs/statics/css/theme.css"/><link rel="stylesheet" href="/adios-blogs/statics/css/layout.css"/><link rel="apple-touch-icon" sizes="180x180" href="/adios-blogs/statics/icons/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/adios-blogs/statics/icons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/adios-blogs/statics/icons/favicon-16x16.png"/><link rel="manifest" href="/adios-blogs/statics/icons/site.webmanifest"/><link id="hl-github" rel="stylesheet" href="/adios-blogs/statics/css/highlight.js/github.css"/><link rel="stylesheet" href="/adios-blogs/statics/css/markdown.css"/><link rel="stylesheet" href="/adios-blogs/statics/css/katex/katex.min@0.5.1.css"/><link rel="stylesheet" href="/adios-blogs/statics/css/post.css"/></head><body class="theme-light"><div id="app"><div id="app-container"><header class="app-post-header pure-g"><div class="pure-u-1"><div class="pure-g app-post-header--box"><h1 class="pure-u-1 post-header-title">React Hooks核心逻辑实现</h1><div class="pure-u-1 post-header-info"><p class="post-header-info--created"><svg class="icon icon" aria-hidden="true"><use xlink:href="#calendar" x="0" y="0" width="16" height="16"></use></svg><span>30/07/2022 12:56</span></p><span class="post-header-info--divider">·</span><p class="post-header-info--author"><svg class="icon icon" aria-hidden="true"><use xlink:href="#pencil-alt" x="0" y="0" width="16" height="16"></use></svg><span>wiskewu</span></p></div></div></div></header><div class="pure-g app-post-navigation"><span click="toggleTheme()"><a href="/adios-blogs/"><svg class="icon icon" aria-hidden="true" style="width:24px;height:24px;"><use xlink:href="#home" x="0" y="0" width="24" height="24"></use></svg></a></span><span class="theme-btn" onclick="toggleTheme(this)"><svg class="icon icon" aria-hidden="true" style="width:24px;height:24px;"><use xlink:href="#sun" x="0" y="0" width="24" height="24"></use></svg></span></div><hr/><main class="app-body"><section class="app-post-body"><article class="markdown app-post-body-content"><blockquote>
<p>React Hooks are not magic, just arrays.</p>
</blockquote>
<p><code>React</code>钩子函数主要是利用了函数的闭包特性。</p>
<h4 id="usestate基础版" tabindex="-1"><a class="header-anchor" href="#usestate基础版">¶</a>useState基础版</h4>
<p>从代码看<code>useState</code>如何实现：</p>
<pre class="language-javascript" data-lang="Javascript"><code><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyReact</span> = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">let</span> _val; <span class="hljs-comment">// 当前值</span>
    <span class="hljs-keyword">return</span> {
        <span class="hljs-title function_">render</span>(<span class="hljs-params">Component</span>) {
            <span class="hljs-keyword">const</span> <span class="hljs-title class_">Comp</span> = <span class="hljs-title class_">Component</span>();
            <span class="hljs-title class_">Comp</span>.<span class="hljs-title function_">render</span>(); <span class="hljs-comment">// 调用组件的渲染器</span>
            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Comp</span>;
        },
        <span class="hljs-title function_">useState</span>(<span class="hljs-params">initialValue</span>) {
            _val = _val || initialValue; <span class="hljs-comment">// 每次运行时都重新赋值</span>
            <span class="hljs-keyword">function</span> <span class="hljs-title function_">setState</span>(<span class="hljs-params">newVal</span>) {
                _val = newVal; <span class="hljs-comment">// 更新值</span>
            }
            <span class="hljs-keyword">return</span> [_val, setState];
        }
    }
})();
</code></pre>
<p>使用案例：</p>
<pre class="language-javascript" data-lang="Javascript"><code><span class="hljs-comment">// 通过返回一个对象来模拟组件的渲染和更新</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title class_">MyReact</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">click</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>),
        <span class="hljs-attr">render</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;render: &#x27;</span>, { count });
    };
}

<span class="hljs-keyword">let</span> <span class="hljs-title class_">App</span>;
<span class="hljs-title class_">App</span> = <span class="hljs-title class_">MyReact</span>.<span class="hljs-title function_">render</span>(<span class="hljs-title class_">Counter</span>); <span class="hljs-comment">// render: { count: 0 }</span>
<span class="hljs-title class_">App</span>.<span class="hljs-title function_">click</span>(); <span class="hljs-comment">// mock event</span>
<span class="hljs-title class_">App</span> = <span class="hljs-title class_">MyReact</span>.<span class="hljs-title function_">render</span>(<span class="hljs-title class_">Counter</span>); <span class="hljs-comment">// render: { count: 1 }</span>
</code></pre>
<h4 id="useeffect基础版" tabindex="-1"><a class="header-anchor" href="#useeffect基础版">¶</a>useEffect基础版</h4>
<p>上述代码我们利用闭包实现了一个微型的<code>useState</code>钩子函数。<br>
利用相同的原理，我们可以实现一个微型的<code>useEffect</code>钩子函数。</p>
<pre class="language-javascript" data-lang="Javascript"><code><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyReact</span> = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-comment">// 存放state</span>
    <span class="hljs-keyword">let</span> _val;
    <span class="hljs-comment">// 存放依赖项</span>
    <span class="hljs-keyword">let</span> _deps;

    <span class="hljs-keyword">return</span> {
        <span class="hljs-title function_">render</span>(<span class="hljs-params">Component</span>) {
            <span class="hljs-keyword">const</span> <span class="hljs-title class_">Comp</span> = <span class="hljs-title class_">Component</span>();
            <span class="hljs-title class_">Comp</span>.<span class="hljs-title function_">render</span>();
            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Comp</span>;
        },
        <span class="hljs-title function_">useEffect</span>(<span class="hljs-params">callback, depArray</span>) {
            <span class="hljs-comment">// 没有依赖的情况下每次渲染都会执行effect</span>
            <span class="hljs-keyword">const</span> hasNoDeps = !depArray;
            <span class="hljs-comment">// 首次渲染或依赖项变化，则也会重新执行依赖</span>
            <span class="hljs-keyword">const</span> hasDepsChanged = _deps ? !depArray.<span class="hljs-title function_">every</span>(<span class="hljs-function">(<span class="hljs-params">el, i</span>) =&gt;</span> el === _deps[i]) : <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">if</span> (hasNoDeps || hasDepsChanged) {
                <span class="hljs-title function_">callback</span>();
                <span class="hljs-comment">// 若副作用被执行，则更新依赖项</span>
                _deps = depArray;
            }
        },
        <span class="hljs-title function_">useState</span>(<span class="hljs-params">initialValue</span>) {
            _val = _val || initialValue;
            <span class="hljs-keyword">function</span> <span class="hljs-title function_">setState</span>(<span class="hljs-params">newVal</span>) {
                _val = newVal;
            }

            <span class="hljs-keyword">return</span> [_val, setState];
        }
    };
})();
</code></pre>
<p>使用示例：</p>
<pre class="language-javascript" data-lang="Javascript"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title class_">MyReact</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);
    <span class="hljs-title class_">MyReact</span>.<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;effect: &#x27;</span>, count);
    }, [count]);

    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">click</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>),
        <span class="hljs-attr">noop</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setCount</span>(count),
        <span class="hljs-attr">render</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;render: &#x27;</span>, { count });
    };
}

<span class="hljs-keyword">let</span> <span class="hljs-title class_">App</span>;
<span class="hljs-title class_">App</span> = <span class="hljs-title class_">MyReact</span>.<span class="hljs-title function_">render</span>(<span class="hljs-title class_">Counter</span>);
<span class="hljs-comment">// effect: 0</span>
<span class="hljs-comment">// render: { count: 0 }</span>

<span class="hljs-title class_">App</span>.<span class="hljs-title function_">click</span>();
<span class="hljs-title class_">App</span> = <span class="hljs-title class_">MyReact</span>.<span class="hljs-title function_">render</span>(<span class="hljs-title class_">Counter</span>);
<span class="hljs-comment">// effect: 1</span>
<span class="hljs-comment">// render: { count: 1 }</span>

<span class="hljs-title class_">App</span>.<span class="hljs-title function_">noop</span>();
<span class="hljs-title class_">App</span> = <span class="hljs-title class_">MyReact</span>.<span class="hljs-title function_">render</span>(<span class="hljs-title class_">Counter</span>);
<span class="hljs-comment">// render: { count: 1 } 没有任何副作用</span>

<span class="hljs-title class_">App</span>.<span class="hljs-title function_">click</span>();
<span class="hljs-title class_">App</span> = <span class="hljs-title class_">MyReact</span>.<span class="hljs-title function_">render</span>(<span class="hljs-title class_">Counter</span>);
<span class="hljs-comment">// effect: 2</span>
<span class="hljs-comment">// render: { count: 2 }</span>

</code></pre>
<h4 id="进阶" tabindex="-1"><a class="header-anchor" href="#进阶">¶</a>进阶</h4>
<p>虽然上述代码中我们看似实现了<code>useState</code>、<code>useEffect</code>核心逻辑，但是它们都是只能在单例模式下运行，多个<code>useState</code>或<code>useEffect</code>将会导致逻辑混乱。<br>
下面我们将实现一个较为完整的hooks版本，核心的要点就是使用<strong>数组+迭代+闭包</strong>：</p>
<pre class="language-javascript" data-lang="Javascript"><code><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyReact</span> = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">let</span> hooks = []; <span class="hljs-comment">// 保存state或依赖项</span>
    <span class="hljs-keyword">let</span> currentHook = <span class="hljs-number">0</span>; <span class="hljs-comment">// hooks迭代索引</span>

    <span class="hljs-keyword">return</span> {
        <span class="hljs-title function_">render</span>(<span class="hljs-params">Component</span>) {
            <span class="hljs-keyword">const</span> <span class="hljs-title class_">Comp</span> = <span class="hljs-title class_">Component</span>();
            <span class="hljs-title class_">Comp</span>.<span class="hljs-title function_">render</span>();
            currentHook = <span class="hljs-number">0</span>; <span class="hljs-comment">// 组件渲染完毕后重置迭代索引值</span>
            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Comp</span>;
        },
        <span class="hljs-title function_">useEffect</span>(<span class="hljs-params">callback, depArray</span>) {
            <span class="hljs-keyword">const</span> hasNoDeps = !depArray;
            <span class="hljs-comment">// 每次执行时获取记录的依赖项</span>
            <span class="hljs-keyword">const</span> deps = hooks[currentHook]; <span class="hljs-comment">// 类型为数组或undefined</span>
            <span class="hljs-keyword">const</span> hasDepsChanged = deps ? !depArray.<span class="hljs-title function_">every</span>(<span class="hljs-function">(<span class="hljs-params">el, i</span>) =&gt;</span> el === deps[i]) : <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">if</span> (hasNoDeps || hasDepsChanged) {
                <span class="hljs-title function_">callback</span>();
                <span class="hljs-comment">// 更新依赖项</span>
                hooks[currentHook] = depArray;
            }
            <span class="hljs-comment">// 下一个迭代</span>
            currentHook++;
        },
        <span class="hljs-title function_">useState</span>(<span class="hljs-params">initialValue</span>) {
            hooks[currentHook] = hooks[currentHook] || initialValue; <span class="hljs-comment">// 类型为any或undefined</span>
            <span class="hljs-comment">// 此处是为了消除闭包对setState的影响，防止执行setState时索引值不正确</span>
            <span class="hljs-keyword">const</span> setStateHookIndex = currentHook;
            <span class="hljs-keyword">const</span> <span class="hljs-title function_">setState</span> = (<span class="hljs-params">newVal</span>) =&gt; {
                hooks[setStateHookIndex] = newVal;
            }
            <span class="hljs-comment">// 下一个迭代</span>
            <span class="hljs-keyword">return</span> [hooks[currentHook++], setState];
        }
    };
})();
</code></pre>
<p>请注意这行代码<code>const setStateHookIndex = currentHook;</code>，看起来没做什么事情，实际上它利用闭包将当前上下文的索引值记录下来，便于后续<code>setState</code>时能取到当时定义时的索引值。如果此处不这么写，将会导致<code>setState</code>赋值位置错误。</p>
<p>使用案例:</p>
<pre class="language-javascript" data-lang="Javascript"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title class_">MyReact</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);
    <span class="hljs-comment">// 可以同时使用多个useState</span>
    <span class="hljs-keyword">const</span> [text, setText] = <span class="hljs-title class_">MyReact</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);

    <span class="hljs-title class_">MyReact</span>.<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;effect: &#x27;</span>, count, text);
    }, [count, text]);

    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">click</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>),
        <span class="hljs-attr">type</span>: <span class="hljs-function">(<span class="hljs-params">txt</span>) =&gt;</span> <span class="hljs-title function_">setText</span>(txt),
        <span class="hljs-attr">noop</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setCount</span>(count),
        <span class="hljs-attr">render</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;render: &#x27;</span>, { count, text }),
    };
}

<span class="hljs-keyword">let</span> <span class="hljs-title class_">App</span>;
<span class="hljs-title class_">App</span> = <span class="hljs-title class_">MyReact</span>.<span class="hljs-title function_">render</span>(<span class="hljs-title class_">Counter</span>);
<span class="hljs-comment">// effect: 0 foo</span>
<span class="hljs-comment">// render: { count: 0, text: &#x27;foo&#x27; }</span>

<span class="hljs-title class_">App</span>.<span class="hljs-title function_">click</span>();
<span class="hljs-title class_">App</span> = <span class="hljs-title class_">MyReact</span>.<span class="hljs-title function_">render</span>(<span class="hljs-title class_">Counter</span>);
<span class="hljs-comment">// effect: 1 foo</span>
<span class="hljs-comment">// render: { count: 1, text: &#x27;foo&#x27; }</span>

<span class="hljs-title class_">App</span>.<span class="hljs-title function_">type</span>(<span class="hljs-string">&#x27;bar&#x27;</span>);
<span class="hljs-title class_">App</span> = <span class="hljs-title class_">MyReact</span>.<span class="hljs-title function_">render</span>(<span class="hljs-title class_">Counter</span>);
<span class="hljs-comment">// effect: 1 bar</span>
<span class="hljs-comment">// render: { count: 1, text: &#x27;bar&#x27; }</span>

<span class="hljs-title class_">App</span>.<span class="hljs-title function_">noop</span>();
<span class="hljs-title class_">App</span> = <span class="hljs-title class_">MyReact</span>.<span class="hljs-title function_">render</span>(<span class="hljs-title class_">Counter</span>);
<span class="hljs-comment">// 没有副作用执行</span>
<span class="hljs-comment">// render: { count: 1, text: &#x27;bar&#x27; }</span>

<span class="hljs-title class_">App</span> = <span class="hljs-title class_">MyReact</span>.<span class="hljs-title function_">render</span>(<span class="hljs-title class_">Counter</span>);
<span class="hljs-comment">// effect: 2 bar</span>
<span class="hljs-comment">// render: { count: 2, text: &#x27;bar&#x27; }</span>

</code></pre>
<h4 id="总结" tabindex="-1"><a class="header-anchor" href="#总结">¶</a>总结</h4>
<p>基本的实现原理就是使用一个钩子数组和一个索引，索引随着每个钩子被调用而增加，并在组件被渲染时重置钩子索引，以便下次组件渲染前能正确执行钩子。</p>
<p>上述代码只能在单个组件上进行使用，暂未考虑多组件的情况。</p>
<hr>
<h4 id="延伸" tabindex="-1"><a class="header-anchor" href="#延伸">¶</a>延伸</h4>
<p>其实从上述钩子的实现中，我们可以重新理解<code>React</code><a href="https://zh-hans.reactjs.org/docs/hooks-rules.html#only-call-hooks-at-the-top-level">官方</a>对钩子函数使用的规则限制：</p>
<ul>
<li>只在最顶层使用Hooks</li>
<li>只在React函数中调用Hooks（不要在普通的 JavaScript 函数中调用 Hook）</li>
</ul>
<h5 id="只在最顶层使用hooks" tabindex="-1"><a class="header-anchor" href="#只在最顶层使用hooks">¶</a>只在最顶层使用Hooks</h5>
<p>不要在循环，条件或嵌套函数中调用<code>Hook</code>，确保总是在你的<code>React</code>函数的最顶层以及任何<code>return</code>之前调用他们。遵守这条规则，你就能确保<code>Hook</code>在每一次渲染中都<strong>按照同样的顺序</strong>被调用。这让<code>React</code>能够在多次的<code>useState</code>和<code>useEffect</code>调用之间保持<code>hook</code>状态的正确。</p>
<h5 id="参考链接" tabindex="-1"><a class="header-anchor" href="#参考链接">¶</a>参考链接</h5>
<ul>
<li><a href="https://www.netlify.com/blog/2019/03/11/deep-dive-how-do-react-hooks-really-work/">Deep Dive: How do React hooks really work</a></li>
</ul>
</article></section></main><section class="app-post-footer"><div class="pure-g app-post-footer--box"><div class="pure-u-1 post-footer-updated"><svg class="icon icon" aria-hidden="true"><use xlink:href="#calendar" x="0" y="0" width="16" height="16"></use></svg><span>Updated at 31/07/2022 15:14</span></div><div class="pure-u-1"><div class="pure-g"><svg class="icon icon" aria-hidden="true"><use xlink:href="#tag" x="0" y="0" width="16" height="16"></use></svg><ul class="pure-g post-footer-tags"><li><a href="/adios-blogs/tags/react/1.html" title="React">React</a></li><li><a href="/adios-blogs/tags/hooks/1.html" title="Hooks">Hooks</a></li></ul></div></div><div class="pure-u-1"><div class="pure-g"><svg class="icon icon" aria-hidden="true"><use xlink:href="#folder" x="0" y="0" width="16" height="16"></use></svg><ul class="pure-g post-footer-categories"><li><a href="/adios-blogs/categories/前端/1.html" title="前端">前端</a></li></ul></div></div></div></section><style>body {
    scroll-behavior: smooth;
}
ol.toc-list {
    counter-reset: list-item;
}
li.toc-list-item {
    display: block;
    counter-increment: list-item;
}
li.toc-list-item::before {
    content: counters(list-item,'.') ' ';
}
a.toc-list-item-link {
    text-decoration: none;
}

#toc {
    position: fixed;
    right: -22rem;
    top: 0;
    width: 22rem;
    height: 100vh;
    transition: right .3s;
    z-index: 1;
    background-color: var(--toc-bg-color);
}
#toc.toc-show {
    right: 0em;
}
#toc-container {
    width: 100%;
    height: 100%;
    box-sizing: border-box;
    padding: 2em;
    max-height: 100%;
    overflow-y: auto;
}
#toc-container > h3 { margin: 0; margin-bottom: 2em; }
#toc-container > nav.table-of-contents ol {
    margin: 0; padding: 0;
}
#toc-container > nav.table-of-contents li.toc-list-item ol {
    padding-left: 2em;
}
nav.table-of-contents li.toc-list-item a.toc-list-item-link::after {
    display: block;
    content: '';
    margin-bottom: 0.3em;
}
span#toc-btn {
    position: absolute;
    display: block;
    left: -28px;
    top: 50%;
    bottom: 0;
    transform: translateY(-50%);
    width: 28px;
    height: 28px;
    cursor: pointer;
    z-index: 1;
    opacity: .5;
}
#toc.toc-show span#toc-btn {
    left: 0px;
    transition: left .3s;
}

@media screen and (max-width: 412px) {
    #toc {
        display: none;
    }
}
</style><div class="toc-show" id="toc"><div id="toc-container"><h3>目录</h3><nav class="table-of-contents"><ol class="toc-list"><li class="toc-list-item"><a class="toc-list-item-link" href="#usestate%E5%9F%BA%E7%A1%80%E7%89%88">useState基础版</a></li><li class="toc-list-item"><a class="toc-list-item-link" href="#useeffect%E5%9F%BA%E7%A1%80%E7%89%88">useEffect基础版</a></li><li class="toc-list-item"><a class="toc-list-item-link" href="#%E8%BF%9B%E9%98%B6">进阶</a></li><li class="toc-list-item"><a class="toc-list-item-link" href="#%E6%80%BB%E7%BB%93">总结</a></li><li class="toc-list-item"><a class="toc-list-item-link" href="#%E5%BB%B6%E4%BC%B8">延伸</a><ol class="toc-list"><li class="toc-list-item"><a class="toc-list-item-link" href="#%E5%8F%AA%E5%9C%A8%E6%9C%80%E9%A1%B6%E5%B1%82%E4%BD%BF%E7%94%A8hooks">只在最顶层使用Hooks</a></li><li class="toc-list-item"><a class="toc-list-item-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li></ol></li></ol></nav></div><span id="toc-btn"><svg class="icon icon" aria-hidden="true" style="width:28px;height:28px;"><use xlink:href="#map" x="0" y="0" width="28" height="28"></use></svg></span></div><script>~(function() {
    var btn = document.getElementById('toc-btn');
    var toc = document.getElementById('toc');
    if (btn && toc) {
        btn.addEventListener('click', function () {
            toc.classList.toggle('toc-show');
        });
    }
})();</script><style>.scroll-btn {
    position: fixed;
    display: none;
    right: 3em;
    bottom: 4.5em;
    width: 28px;
    height: 28px;
    opacity: .5;
    cursor: pointer;
    z-index: 1;
}
.scroll-btn:hover {
    opacity: 1;
}
</style><span class="scroll-btn"><svg class="icon icon" aria-hidden="true" style="width:28px;height:28px;"><use xlink:href="#arrow-up" x="0" y="0" width="28" height="28"></use></svg></span><script>function getBtn() {
    var btns = document.getElementsByClassName('scroll-btn');
    if (btns && btns.length) return btns[0];
    return null;
}
function scrollTop(btn) {
    window.scrollTo({
        top: 0,
        behavior: 'smooth'
    });
    btn.style.display = 'none';
}

function debouce(callback, ms) {
    var t = null;
    return function () {
        var args = Array.prototype.slice.call(arguments);
        var ctx = this;
        if (t) {
            clearTimeout(t);
        }
        t = setTimeout(function () {
                clearTimeout(t);
                t = null;
                callback.apply(ctx, args);
            }, ms);
    }
}

//- place here for dom ready
~(function () {
    function setStyle() {
        var btn = getBtn();
        var sH = window.scrollY;
        if (btn) {
            btn.style.display = sH > 100 ? 'inline' : 'none';
        }
        return btn;
    }

    var btn = setStyle();
    if (btn) {
        btn.addEventListener('click', function () {
            scrollTop(this);
        });
        window.onscroll = debouce(setStyle, 500);
    }
    btns = null;
})();</script><footer class="pure-g app-footer"><div class="pure-u-1"><div class="pure-g"><div class="pure-u-1"><abbr class="share-license" title="This site and all its content are licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.">CC BY-NC 4.0</abbr><span class="copyright">&copy; wiskewu. 20222023</span></div><div class="pure-u-1 last-update">站点始于: 2022/07/17 最后更新于: 1/29/2023</div></div></div></footer></div></div></body><script src="/adios-blogs/statics/js/main.js"></script></html>